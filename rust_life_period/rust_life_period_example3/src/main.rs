fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);

    println!("The longest string is {}", result);
}

// 这些引用必须拥有相同的生命周期
//就好比你爸妈在家里房间里，你想找他们其中一个借钱，但只要房间熄灯了，就说明肯定爸妈有一个睡了，不管找谁都别敲门了。'a就是那个提醒的灯

// 指定生命周期参数的方式依赖于函数所做的事情
//下面这个函数中，因为我们只返回变量x的值，所以生命周期只需要为x变量引用即可
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}

/*
    ◦	从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配：
    ◦	如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：
    ⁃	这就是悬垂引用：该值在函数结束时就走出了作用域
    简单来说就是编译器需要知道返回值的生命周期，因为函数在调用完就死了，不能让返回值跟着死
*/
